#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 9016
from pwn import *

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'pwnable.kr'
port = int(args.PORT or 9016)

def start():
    '''Start the exploit against the target.'''
    return connect(host, port)

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

import copy
import enum
import functools
import itertools
import json

from pprint import pformat

def round_down(num: int, to: int) -> int:
    return num - (num % to)

class ConditionSign(enum.Enum):
    BIGGER = b"bigger"
    SMALLER = b"smaller"

class Condition:
    def __init__(self, indices: list[tuple[int, int]], sign: ConditionSign, limit: int) -> None:
        self.indices = indices
        self.sign = sign
        self.limit = limit

    def is_true(self, board: list[list[int]]) -> bool:
        values = [board[i][j] for (i, j) in self.indices]

        assert all(len(value) == 1 for value in values), "cannot test condition on non solved board!"
        
        sum_ = sum([list(value)[0] for value in values])
        
        if self.sign == ConditionSign.BIGGER:
            return sum_ > self.limit
        else:
            return sum_ < self.limit

class Level:
    def __init__(self, board: list[list[set[int]]], condition: Condition) -> None:
        self.board = board
        self.condition = condition

        for (i, j) in itertools.product(range(9), repeat=2):
            self._update_all_relevant_cells(i, j)
    
    @staticmethod
    def _get_all_indices() -> list[tuple[int, int]]:
        return list(itertools.product(range(9), repeat=2))

    @staticmethod
    def _get_square_indices(x: int, y: int) -> list[tuple[int, int]]:
        return [(round_down(x, 3) + i, round_down(y, 3) + j) for (i, j) in itertools.product(range(3), repeat=2)]
    
    @staticmethod
    def _get_row_indices(x: int, y: int) -> list[tuple[int, int]]:
        return [(i, y) for i in range(9)]

    @staticmethod
    def _get_column_indices(x: int, y: int) -> list[tuple[int, int]]:
        return [(x, j) for j in range(9)]

    def _update_all_relevant_cells(self, i: int, j: int):
        """
        if the given cell's value was determined, removes it from the options for other cells in row, column or square
        """
        if len(self.board[i][j]) != 1:
            return
        
        value = list(self.board[i][j])[0]

        for (x, y) in self._get_row_indices(i, j) + self._get_column_indices(i, j) + self._get_square_indices(i, j):
            if (x, y) == (i, j):
                continue

            try:
                self.board[x][y].remove(value)
            except KeyError:
                pass

            if len(self.board[x][y]) == 0:
                raise Exception(f"no options for ({x}, {y}), probably a wrong guess...")

    def _add_single_candidate_from_indices(self, i: int, j: int, indices: list[tuple[int, int]]) -> bool:
        """
        for the given coordinates, checks whether there is a value in row column or square that can be only satisfied by it.
        """
        if len(self.board[i][j]) == 1:
            return False

        all_values = functools.reduce(operator.or_, (self.board[x][y] for (x, y) in indices if (i, j) != (x, y)), set())

        remaining_values = set(range(1, 10)) - all_values
        
        if len(remaining_values) > 1:
            raise Exception(f"too many values! ({i}, {j})")
        
        elif len(remaining_values) == 1:
            if not remaining_values <= self.board[i][j]:
                raise Exception("deduced value but it waas never an option (probably wrong guess...)")

            debug(f"found single candidate for {list(remaining_values)[0]}: ({i}, {j})")
            self.board[i][j] = remaining_values
            self._update_all_relevant_cells(i, j)
            return True
        
        return False

    def _add_single_candidate(self, i: int, j: int) -> bool:
        """
        for the given coordinates, checks whether there is a value in row column or square that can be only satisfied by it.
        """
        indices_list = [
            self._get_column_indices(i, j),
            self._get_row_indices(i, j),
            self._get_square_indices(i, j),
        ]

        return any(self._add_single_candidate_from_indices(i, j, indices) for indices in indices_list)

    def _add_single_candidates(self) -> bool:
        """
        for the each cell, checks whether there is a value in row column or square that can be only satisfied by it.
        """
        return any(self._add_single_candidate(i, j) for (i, j) in self._get_all_indices())
    
    def _is_done(self) -> bool:
        return all(all(len(opt) == 1 for opt in row) for row in self.board)
    
    def _is_valid(self) -> bool:
        if not self._is_done():
            return False

        for (i, j) in self._get_all_indices():
            indices_list = [
                self._get_column_indices(i, j),
                self._get_row_indices(i, j),
                self._get_square_indices(i, j),
            ]

            for indices in indices_list:
                if not functools.reduce(operator.or_, (self.board[x][y] for (x, y) in indices), set()) == set(range(1, 10)):
                    return False

        return self.condition.is_true(self.board)

    def _try_guess(self):
        """
        makes a guess about some undetermined cell. chooses the correct guess.
        """
        i, j = next((i, j) for (i, j) in self._get_all_indices() if len(self.board[i][j]) != 1)
        debug(f"making some guesses about ({i}, {j})...")

        for val in self.board[i][j]:
            debug(f"({i}, {j})={val}?")
            board = copy.deepcopy(self.board)
            board[i][j] = set([val])
            
            try:
                sublevel = Level(board, self.condition)
                sublevel.solve()
            except Exception:
                continue

            self.board = sublevel.board
            break
        else:
            raise Exception("no guess was correct (probably wrong guess...)")

    def solve(self):
        # try to make some progress with simple heuristics...
        while (not self._is_done()) and self._add_single_candidates():
            pass

        if self._is_valid():
            # done!
            return

        if self._is_done():
            # done but not valid...?
            raise Exception("done solving but got incorrect solution (probably wrong guess...)")

        # done with any new progress, time to make some guesses...
        self._try_guess()

        if not self._is_valid():
            raise Exception("invalid solution (probably wrong guess)")

def parse_output(io: tube) -> tuple[list[list[int]], list[tuple[int, int]], ConditionSign, int]:
    level = int(io.recvregex(b"Stage (\d+)\n", capture=True).groups()[0])
    debug(f"level {level}")

    board = [eval(line) for line in io.recvuntil(b"- additional rule -", drop=True).strip().split(b"\n")]

    match = io.recvregex(b"sum of the following numbers \(at row,col\) should be (bigger|smaller) than (\d+)\n", capture=True)

    indices = [eval(line.split(b" : ")[1]) for line in io.recvuntil(b"solution?", drop=True).splitlines()]

    sign, limit = match.groups()

    return board, indices, ConditionSign(sign), limit

def do_level(io: tube):
    board, indices, sign, limit = parse_output(io)
    
    debug(f"initial board:\n{pformat(board)}")

    condition = Condition([(x - 1, y - 1) for (x, y) in indices], sign, int(limit))

    level = Level(
        [[set([num]) if num else set(range(1,10)) for num in row] for row in board],
        condition
    )

    level.solve()

    solution = [[list(values)[0] for values in row] for row in level.board]
    debug(f"solution:\n{pformat(solution)}")

    io.sendline(json.dumps(solution).encode())

io = start()

io.sendline(b"")

io.sendlineafter(b"press enter to start game", b"")

with log.progress("solving level") as p:
    for i in range(1, 101):
        p.status(f"{i}")
        do_level(io)
    
    p.status("done!")

io.recvuntil(b"congratz! get your flag.\n")
success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")
